# 概述：
    1，线程是 CPU使用基本单元，它由 线程ID，程序计数器，寄存器集合和栈组成。
    它与属于同一个进程的其他线程共享代码段，数据段和其他操作系统资源，如打开文件和信号。

    2，适应场景：
        a，应用程序 通常是作为一个具有多个 控制线程的独立进程 实现。
        b，在远程过程调用（RPC）通过提供一种类似于普通函数或子程序调用的通信机制，以允许进程通信。
        c，操作系统也是多线程的，少数线程在内核中运行，每个线程完成一个指定的任务，如管理设备和中断处理。

    3，优点：
        a，相应度高
        b，资源共享
        c，经济
        d，多处理器体系结构的利用

    4，多线程模型
        提供线程支持的两种方法：
            a，用户层的用户线程
            b，内核层的内核线程

        用户线程和内核线程之间的多种关系：
            a，多对一模型
               将许多 用户级线程 映射到一个 内核线程。
               优点：
                    线程管理 是由 线程库 在用户空间进行的，因而效率比较高。
               缺点：
                    首先，一个线程执行了阻塞系统调用，那么整个进程会阻塞。
                    其次，任意时刻只有一个线程能访问内核，多个线程不能并行运行在多处理器上。
            案例：Green thread（Solaris所用线程库），GNU可移植线程（GNU Portable Threads）

            b，一对一模型
               一对一模型将 每个 用户线程 映射到一个 内核线程。
               优点：
                    在一个线程执行阻塞系统调用时，能允许另一个线程继续执行，所以它提供了比多对一模型更好的并发
                    也允许多个线程能并行地允许在多处理器系统上。
               缺点：
                    由于每创建一个 用户线程 就需要创建一个 内核线程，而创建 内核线程 的开销会影响 应用程序的性能，
                    所以这种模型的实现系统基本都限制了系统所支持的线程数量。
            案例：Linux 系统于Windows操作系统族

            c，多对多模型
                多对多模型多路复用了许多用户线程到同样数量或更小数量的内核线程上。
                内核线程的数量可能与特定应用程序或特定机器有关。
                优点：
                    开发人员可创建 任意多的 用户线程，并且相应 内核线程 能在 多处理器系统上 并发 执行。
                    当一个线程执行阻塞 调用系统调用时，内核能调度另一个线程来执行。
            延伸：二级模型：
                在保留多路复用许多用户线程到同样数量或更小数量的内核线程上，但也允许将一个用户线程绑定到某个内核线程上。
            案例：
                IRIX，HP-UX，Tru64 UNIX等操作系统所支持。
                Solaris在9之前版本中支持二级模型，但从9开始使用一对一模型。


    5，线程库
       为程序员提供创建和管理线程的API，主要有两种方法来实现线程库
         第一种方法
            是在 用户空间 提供一个 没有内核支持 的库，此库的所有 代码和数据结构 都存储在 用户空间中。
            调用库中的一个函数只是导致了 用户空间的一个 本地函数调用，而不是 系统调用。

         第二种方法
            是执行一个有操作系统直接支持的 内核级的库。此时，库的代码和数据结构存在于 内核空间中。
            调用库中的一个API函数通常会导致内核的系统调用。

       目前使用的三种线程库：
       1，POSIX Pthread
            Pthread作为POSIX标准的扩展，可以提供用户级或内核级的库。
       2，Win32
            Win32适用Windows操作系统的内核级线程库，
       3，Java
            JVM的实例是允许在宿主操作系统之上，Java线程API通常采用宿主系统上的线程库来实现。

       Pthread
       是由 POSIX 标准为线程创建和同步定义的API。是线程行为的规范，却不是实现。



