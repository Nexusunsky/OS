# 习题
    1，举两个多线程程序设计的例子，其中多线程的性能比单线程的性能差。
        a，当线程数量过多，并且会频繁的创建和销毁时，多线程的性能会比单线程差。
        b，

        答：
        a，所有的顺序执行的程序不应该是多线程的。例如一个计算个税的程序。
        b，另一个例子是"shell"程序，例如C-Shell，或是内核Shell，
           这样的程序必须紧密的监控它自己的工作空间例如，打开文件，环境变量，以及当前的工作目录。



    2，描述线程库进行用户级线程上下文切换的过程所采取的措施。
        答：用户线程的上下文切换和内核线程的切换是非常相似的，
           尽管这需要依赖线程库，以及用户线程和内核线程之间的对应关系
           一般而言，用户线程的上下文切换涉及，获取用户线程的LWP（最轻量进程）
           以及用另一个线程替代这个用户线程等。这个行为通常涉及 保存和恢复 寄存器的状态。

    3，在什么环境中，采用多内核线程的多线程方法比单线程处理器系统的单线程提供更好的性能？
        答：
        当内核线程碰到页错误时，一种有用的方式是，切入到另一个内核线程中。
        另一方面，一个 单线程进程 在错误页发生时将不能表现出更有价值。
        因此，当程序可能会经常出现错误页面或者是必须等待其他系统事件的发生时，
        一个多线程的方案将会表现的更好，尽管是在一个但处理器的系统时。

    4，在多线程进程中，下列哪些程序状态组成被共享？
        a，寄存器值
        b，堆内存
        c，全局变量
        d，栈内存
        答：多线程中的线程共享了堆内存和全局变量，
           而每个线程有其自己的寄存器值集以及独立的栈内存。

    5，使用多用户线程的多线程解决方案，在多处理器系统中可以比在单处理器系统中获得更好的性能吗？
        答：由多用户线程组成的多线程系统并不能同时利用多处理器系统的多个进程。
        操作系统仅仅看到 一个进程 并不会在将进程中的多个线程调度到处理器上。
        因此，在 多处理器系统 上去执行多个用户线程并不能带来性能上的优势，

    6，如4.5.2所述。Linux并不区分 进程 和 线程，而是将两者同样对待，将一个任务视为进程或线程，
    这取决于传递给clone()系统调用的标志集。然而，许多操作系统，如WindowsXP和Solaris，对待线程和进程不一样。
    通常，这类系统使用标记，其中进程的 数据结构 中包含指向 属于进程的不同线程。
    试在 内核 中比较这两种对 进程和线程 建模的方法。
        答：
            一方面：在进程和线程被视为同种实体的系统中，一些相关的操作系统代码可以被简化。
            例如，在调度过程中，调度器可以不需要一些 附加代码 来检验关联到进程的线程
            而认为不同的线程和进程是平等的，

            另一方面，这样的统一性使得直接来强行限制进程范围的资源变得困难。
            因此，需要一些额外的复制性来执行些相关的计算工作用于区分与进程相关联的线程有哪些。

    7，程序的输出是什么？
        LINE C:
            CHILD: value=5;
        LINE P:
            PARENT: value=0;

    8，考虑 多处理器系统 和采用 多对多线程模式 编写的多线程程序，
    使程序中 用户级别线程数比系统中处理器数多。讨论下列情形的性能影响。
        答：
            a，分配给程序的内核线程数比处理器数少。
                答：仍然会有些处理器处于静止状态，
                因为调度器的映射只是将内核线程和处理器作映射，而不是用户线程。

            b，分配给程序的内核线程数与处理器数相等。
                答：那么可能所有的处理器会同时被调用。
                然而，当一个内核线程在内核内部被阻塞时（由于错误也，或者执行系统调用），
                正在处理处理器仍然会静止。

            c，分配给程序的内核线程数比处理器数多，但少于用户线程数。
                答：
                当内核线程多于处理器时，被阻塞的内核线程将会被置换出而有利于另一个等待线程立即执行，
                因此而能增加多处理器系统的使用。


    9，编写一个多线程的程序Pthread，来输出素数。
    程序应该这样工作：用户运行程序时在命令行输入一个数字，
    然后创建一个独立线程来输出小于或等于用户输入数的所有素数。
        答：prime_stdout.c



    11，编写程序输出Fibonacci数列，
     使用Pthread，用户运行程序时在命令行输入要产生Fibonacci序列的数，
     然后程序创建一个新的线程来产生 Fibonacci ,把这个序列放到线程共享的数据中（数组可能是最方便的一种数据结构）
     当线程执行完成后，父线程将输出由子线程产生的序列。由于在子线程在结束前，父线程不能开始输出Fibonacci序列，
     因此父线程必须等到自线程的结束。
        答：














