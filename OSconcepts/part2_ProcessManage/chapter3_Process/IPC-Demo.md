POSIX共享内存：
    共享内存的POSIX API：

    1，进程必须首先用系统调用shmget() 创建 共享内存段（shmget()由Shared Memory GET派生而来）
    '''
        segment_id = shmget(IPC_PRIVATE, size, S_IPUSR | S_IWUSR);
    '''
        第一个参数指的是共享内存段关键字（标识符）
        第二个参数指的是共享内存段的大小（按字节数）
        第三个参数标识模式，明确如何使用共享内存段----即用来读，用来写或者二者皆有。
        返回值，一个共享内存段整数标识值，供其他想要使用共享内存区域的进程指明该标识符。

    2，想访问共享内存段的进程必须采用shmat(SHard Memory ATtach)系统调用，来将其 加入 地址空间。
    '''
        shared_memory = (char*)shmat(id, NULL, 0);
    '''
        第一个参数希望加入的共享内存段的整数标识值
        第二个参数是内存中的一个指针，表示将要加入到的共享内存所在，传NULL，则由操作系统为用户选择
        第三个参数指的一个标识模式，如果设置该模式，则允许将要加入到的共享内存区域为只读模式，如果设置为0，则允许共享内存进行读和写操作。
        返回值，一个指向附属的共享内存区域的内存中初始位置的指针。

    3，一旦共享内存区域被加入到进程的地址空间，进程就可以采用从shmat()返回的指针，作为一般的内存访问来访问共享内存。
        例如：
            '''
                sprintf(shared_memory, "Writing to shared memory");
            '''
        其他共享这个内存段的进程将会看到这个更新。
    通常，采用已有共享内存段的进程首先将共享内存段加入其他地址空间，然后在访问（或者更新）共享内存区域。

    4，而当一个进程不在需要访问共享内存段时，它将从其他地址空间中分离出这一段。
       分离出共享内存的地址空间：
       '''
            shmdt(shared_memory);
       '''
        参数：共享内存区域的指针


    5，采用系统调用shmctl()，将共享内存从系统中删除。
    '''
        shmctl(IPC_RMID, shared_memory);
    '''

Mach实例：
    Mach 内核支持多任务的创建和删除，这里的任务与进程相似，但能有多个线程控制。
    Mach的绝大多数通信（包括绝大多数系统调用和所有任务间消息）通过消息实现的。
    消息通过邮箱（Mach称之为端口）来发送和接收。

    即使系统调用也是通过消息进行的。每个任务在创建时，也创建了两个特别邮箱：
        a，内核邮箱
        b，通报邮箱
    内核使用内核邮箱与任务通信，使用通报邮箱发送时间发生的通知。

    消息传输只需要三个系统调用。
        1，调用msg_send()向邮箱发送消息。
        2，消息可通过msg_receive()接收。
        3，远程过程调用（RPC）通过msg_rpc()执行，它只能发送并只等待来自发送者的一个返回消息

    系统调用port_allocate()创建新邮箱并认为其消息队列分配空间。消息队列的最大长度为8
    创建邮箱是该邮箱拥有着的任务。
    拥有者也被允许接收来自邮箱的消息。一次只有一个任务能拥有邮箱或从邮箱接收，但是如果需要，这些权利也能发送给其他任务。
    开始时，邮箱的消息队列为空，随着消息向邮箱发送，消息被复制到邮箱中。所以消息具有同样优先级。
    Mach确保来自同一个发送者的多个消息按照FIFO顺序来排队，但不保证绝对顺序。

    消息本身由固定大小的头部和可变长的数据部分组成。
        1，头部包括消息长度和两个邮箱名，发送时，一个邮箱名是消息发送目的地，一个是发送的邮箱名。
        2，可变部分为具有类型的数据项的链表。链表内的每一项都有类型，大小和值。
        3，消息内所表示的对象类型很重要，因为操作系统定义的对象（拥有权，接收访问权，任务状态，内存段）均可通过消息发送。

    发送和接收操作本身很灵活。
        a，当向邮箱发送消息，而邮箱未满时，消息可复制到邮箱，发送线程继续。
        b，当邮箱已满时。则发送线程有四个选择：
            1，无限等待。
            2，最多等待n毫秒。
            3，根本不等待，而是立即返回。
            4，暂时缓冲消息。即使目标邮箱已满，操心系统还是可以保存一条消息。
            当消息能放进邮箱时一条通报消息会发送到发送者。
            对于给定发送线程，任何时候，仅能有一个给已满有限等待处理的消息。
            通常用于服务器任务，如行式打印机。

    接收操作必须指明从哪个邮箱或邮箱集合来接收消息。
        一个邮箱集合是由任务所声明的，能组合在一起作为一个邮箱满足任务的一组邮箱。
        任务中的线程只能从任务具有接收权限的邮箱或邮箱集合中接收消息。
        系统调用port_status()能返回给定邮箱的消息数量。
        receive()操作试图从如下两次接收消息：
            邮箱集合内的任何邮箱
            特定的（以命名）邮箱。


WindowsXP实例：
    WindowsXP的消息传递工具称为本地过程调用（LPC）工具，在位于同一台机器的的两个进程间通信。
    类似与RPC，但是针对WindowsXP做了优化。

    同Mach，也Xp使用了端口对象以建立和维护两进程间的连接。
    调用子系统的每个客户需要一个通信频道，由端口号提供且不能继承。
    Xp使用两种类型的端口：
        连接端口，称之为对象，为所有进程可见，允许应用程序建立通信频道。
        通信端口
    通信的工作方式如下：
        a，客户机打开系统的连接端口对象的句柄。
        b，客户机发送连接请求。
        c，服务器创建两个私有通信端口，并返回其中之一的句柄给客户机。
        d，客户机和服务器使用相应端口句柄以发送消息或回调。

    XP使用两种端口消息传递技术，端口可在客户句建立频道时被指明。
        a，最为简单的类型适用于小消息，使用端口队列作为中间存储，并将消息从一个进程复制到另一个进程。最多发送256B消息。
        b，客户机发送更大消息，那么可通过 区段对象（构建共享内存） 来传递消息。
            1，在建立频道时，必须确定是否需要发送大消息。
            2，如果客户机确定它确实需要大消息时，需要请求创建一个区段对象，同样，服务器确定回复将是很大消息时，它创建一个区段对象。
            3，为了能够使用区段对象，需要先发送一个小消息（包括区段的一个指针和大小消息）。
            4，当客户程序或服务程序不能马上相应请求时，可以使用回调机制，允许执行异步消息传递。





















