操作系统对于CPU活动的称呼：
    1，批处理系统执行作业
    2，分时系统使用用户程序或任务
    3，本书中经常使用作业与进程。

一，进程：
    进程不只是 程序代码，还包括 当前活动，进程堆栈段，数据段，还可能包括 堆。
        1，程序代码：称为代码段。
        2，当前活动，通过程序计数器的值和处理器寄存器的内容来表示。
        3，堆栈段：包括临时数据，如函数参数，返回地址，局部变量。
        4，数据段：全局变量。
        5，堆：进程运行期间动态运行的内存。

    程序本身不是进程：
        程序只是被动实体，如存储在磁盘上包含一系列指令的文件内容
        而进程是活动实体，有一个程序计数器用来表示下一个要执行的命令和相关资源集合。
        当一个可执行文件被装入内存时，一个程序才能成为进程。

二，进程状态：
    1，新的：进程正在被创建
    2，运行：指令正在被执行
    3，等待：进程等待某个时间的发生（如IO完成或收到信号）
    4，就绪：进程等待分配内存
    5，终止：进程完成执行

三，进程控制块（process control block ，PCB）：
    PCB包含了许多与一个特定进程相关的信息：
    1，进程状态：进程状态
    2，程序计数器：进程要执行的下个指令的地址
    3，CPU寄存器：计算机体系不同，寄存器的数量和类型不同。包括：累加器，索引寄存器，堆栈指针，通用寄存器和其他条件码信息寄存器。
    4，CPU调度信息：进程优先级，调度队列的指针和其他调度参数
    5，内存管理信息：根据操作系统所使用的内存系统，该信息包括基址，和界限寄存器的值，页表，或段表
    6，记账信息：该信息包括CPU时间，实际使用时间，时间界限，记账数据，作业或进程数量
    7，I/O状态信息：该信息包括分配给进程的I/O设备列表，打开的文件列表等
    PCB作为了这些信息的仓库。

四，进程调度：
    多道程序设计的目的是无论何时都有进程在运行，从而使CPU利用率达到最大化。
    分时系统的目的是在进程之间快速切换CPU以便用户在程序运行时能与其进行交互。
    进程调度：选择一个可用的进程（可能从多个可用进程集合中选择）到CPU上执行。

    1，调度队列：
        进程进入系统时，就加入到作业队列中，该队列中包括系统中的所有进程。
        驻留在内存中就绪的，等待运行的进程保存在就绪队列中。
        讨论进程调度的常用表示方法是队列图，有两种队列：就绪队列，一组设备队列。
        新进程开始处于就绪队列。它在就绪队列中等待直到被选中执行或被派遣。
        当进程分配到CPU并执行时，可能发生下面几种事件中的一种：
            a，进程可能发出一个I/O请求，并被放到I/O队列中。
            b，进程可能创建一个新的子进程，并等待其结束。
            c，进程可能由于中断而强制释放CPU，并被放回到就绪队列中。
        对于前两种情况，进程最终从等待状态切换到就绪态，并放回到就绪队列中。
        进程继续这一循环直到终止，到时它将从所有队列中删除，其PCB和资源将得以释放。

    2，调度程序：
        进程在 其生命周期中 会在 各种调度队列 之间迁移。
        为了调度，操作系统 必须按照 某种方式 从这些队列中 选择进程。
        进程选择 是由相对应的 调度程序 来执行。

      通过执行频率区分：
        长期调度程序 或 作业调度程序 从大容量存储设备（通常为磁盘）的 缓存池 中选择进程，并装入内存以准备执行。
        短期调度程序 或 CPU调度程序 从准备执行的进程中选择进程，并为之分配CPU。

        短期调度系统：
            短期调度程序需要频繁地为CPU选择新进程。由于执行之间的时间较短，短期调度程序必须要快。

        长期调度程序
            执行不频繁，在系统内新进程的创建之间可能有数分钟间隔。
            长期调度程序 控制 多道程序设计的程度----内存中的进程数量。
            如果 多道程序的程度 稳定 即指 创建进程 的平均速度 等于 进程离开系统 的平均速度。
            通常，绝大多数进程可以分为： I/O为主 或 CPU为主
            为了达到最好的性能，长期调度程序 应该选择一个合理的包含 I/O为主 和 CPU为主 的组合进程。
            有些系统，可能没有长期调度程序。例如 UNIX ，Windows等分时系统通常没有长期调度程序，
            只是简单地将所有新进程放在内存中以供短期调度程序使用。

        中期调度程序
            分时操作系统，引入了中期操作系统。
            核心思想：
                交换（swapping）：将进程中内存（或从 CPU竞争）中移出，从而降低 多道程序设计的程度。之后，进程能被重新调入内存，并从中断处继续执行。
                为了改善进程组合，或者因内存要求的改变引起了可用内存的过度使用而需要释放内存，就有必要使用交换。


    3，上下文切换：
        进程上下文用进程PCB表示，它包括 CPU寄存器的值，进程状态，和内存管理信息等。
            状态保存：保存CPU当前状态
            状态恢复：重新开始运行
        上下文切换：将 CPU切换到 另一个进程 需要保存 当前进程的状态 并 恢复另一个进程的状态。
        当发生上下文切换时，内核 会将 旧进程的状态 保存在其PCB中，然后装入 经调度要执行的并已保存的新进程的上下文。

五，进程操作
    1，进程创建
        大多数操作系统通过唯一的进程标识符来识别进程(process identifier, pid);
        通常，进程需要一定的资源（CPU时间，内存，文件，I/O设备）来完成其任务。
        在一个进程创建 子进程时，子进程 可能从 操作系统 那里直接获得资源，也可能只从其 父进程 那里获得资源。
        当进程创建新进程时，有两种执行可能：
            a，父进程与子进程并发执行。
            b，父进程等待，直到某个或全部子进程执行完。
        新进程的地址空间也有两种可能：
            a，子进程是父进程的复制品（具有与父进程相同的程序和数据）。
            b，子进程装入另一个新程序。

        在UNIX下，每个进程都用唯一的整数形式的进程标识符。
            通过fork()系统调用，可创建新进程。
            新进程通过复制原来进程的地址空间而成。两个进程都继续执行位于系统调用fork()之后的指令。
            但是，对于子进程，系统调用fork()的返回值为0，，对于父进程，系统调用fork()返回子进程的pid。

            通常，在系统调用fork()后，一个进程会使用，系统调用exec()，以用新程序来取代进程的内存空间。
            系统调用exec()将二进制文件装入内存，并开始执行。
            父进程能创建更多的子进程，或者如果子进程在运行时没什么可做，那么它采用系统调用wait()把自己移出就绪队列类等待子进程的终止。

        在Windows下，采用CreateProcess()函数（与fork()中的父进程创建子进程类似）创建进程。
        然而，fork()中子进程继承了父进程的地址空间，而CreateProcess()生成函数时，需要将一个特殊程序装入子进程的地址空间。
        即：与fork()不需要传递参数不同，CreateProcess(）需要传递至少10个参数。

    2，进程终止
        进程能够通过多种方式终止：
            a，当进程执行完最后的语句并使用系统调用exit()请求操作系统删除自身时。
            此时通过系统调用wait()终止进程可以返回状态码到父进程。所有进程资源（包括物理内存和虚拟内存，打开文件和I/O缓冲）会被操作系统释放。
            b，进程通过系统调用也能终止另一个进程。通常，只有被终止进程的父进程才能执行这一系统调用。记住：父进程要知道子进程的标识符。
            因此，当一个进程创建新进程时，新创建进程的标识符要传递给父进程。

        父进程终止其子进程的原因很多：
            a，子进程使用了超过它所分配到的一些资源，父进程实现检查其子进程状态的机制。
            b，分配给子进程的任务不再需要。
            c，父进程退出，那么操作系统不允许子进程继续。

        有一类系统VMS，如果一个进程终止，那么它的所有子进程也将终止，成为级联终止。
        但是UNIX，在父进程终止时，那么其所有子进程会以init进程作为父进程。



六，进程间通信
    如果一个进程 不能 影响其他进程或被其他进程所影响，那么该进程是 独立的。
    如果一个进程 能 影响其他进程或被其他进程所影响，那么该进程是 协作的。

    需要进程协作的理由：
        1，信息共享：多个用户对同样的信息感兴趣，所以必须提供环境以允许对这些信息进行并发访问。
        2，提高运算速度：多处理单元的CPU，必须将它分成多个子任务，而每个子任务并行执行。
        3，模块化：模块化构造系统，可讲系统功能分成独立进程或线程。
        4，方便：单个用户也可能同时执行许多任务。

    协作进程间通信的两种基本模式：
        1，共享内存：建立起一块供协作进程共享的内存区域，进程通过向此共享区域读或写入数据来交换信息。
            特点：
                a，允许以最快的速度进行方便的通信，可以达到内存的速度。
                b，仅在建立共享内存区域时需要系统调用。

        2，消息传递：通过在协作进程间交换信息来实现通信。
            特点：
                a，使用系统调用的方式实现，易于实现。
                b，需要更多的内核介入。


    消息传递系统：
        有操作系统提供机制，让协作进程能通过消息传递的工具来进行通信。
        消息传递提供两种操作：发送（消息），接受（消息）。

        消息可以是定长或者变长的。
            定长消息：系统实现简单，但是变长任务将变得复杂
            变长消息：系统级实现复杂，但是编程任务简单

        通信线路：进程P，Q之间彼此相互通信需要有通信线路。
        逻辑实现线路和send()/receive()操作的方法:
            a，直接或间接通信
            b，同步或异步通信
            c，自动或显示缓冲

        1，命名：需要通信的进程必须有一个方法以互相引用。
        直接通信：通信的每个进程必须明确地命名通信的接受者或发送者。

            对称寻址：发送和接受进程必须命名对方以便通信。
                send(P, message)：发送消息到线程P
                receive(Q, message)：接受来着线程Q的消息
                这种方案的通信线路有如下属性：
                    a，在需要通信的没对进程之间自动建立线路，进程仅需知道相互通信的标识符。
                    b，一个线路只与两个进程相关
                    c，每对进程之间只有一个线路

            非对称寻址：只要发生者命名接受者，而接受者不需要命名发送者。
                send(P, message)：发送消息到线程P
                receive(id, message)：接受来自任何进程的消息，变量id设置成与其通信的进程名称

            缺点：对称和非对称寻址方案的缺点是限制了进程定义的模块化。


        间接通信：通过邮箱或端口来发送或接受消息。
            邮箱可以抽象为一类对象，进程可以向其中存放消息，也可以从中删除消息，每个邮箱都有一个唯一标识

        此时，一个进程可能通过许多不同的邮箱与其他进程通信。
                send(A, message)：发送消息到邮箱A
                receive(A, message)：接受来自邮箱A的消息

            这种方案，通信线路具有如下属性：
                a，只有在两个进程共享一个邮箱时，才能建立通信线路
                b，一个线路可以与两个或更多的进程相关联
                c，两个通信进程之间可有多个不同的线路，每个线路对应于一个邮箱。

            场景：
            假设，进程P1，P2和P3都共享邮箱A，进程P1发送一个消息到A，而进程P2和P3都对A执行receive()，哪个进程能收到P1所发的消息呢？
            有如下限制：
                a，一个线路最多与两个进程相关联。
                b，一次最多允许一个进程执行receive()
                c，允许系统随意选择一个进程以接受消息（P2和P3，都可以接受消息，但同一时间只有一个进程接消息。）
                系统定一个一个算法选择接受者进程（round robin）可以给发送者标示接受者。

        邮箱类别：
        进程和操作系统都可以拥有邮箱，
            进程拥有的邮箱：
                邮箱是进程地址空间的一部分，那么需要区分
                    拥有者（只能通过邮箱接受消息）
                    使用者（只能向邮箱发送消息）
                当拥有邮箱的进程终止时，那么邮箱将消失，任何进程后来向该邮箱发送消息，都会得知邮箱不存在。

            操作系统拥有的邮箱：
                该类邮箱都是独立存在的，并不属于某个特定的进程。操作系统必须提供机制以允许进程进行如下操作：
                    a，创建新邮箱
                    b，通过邮箱发送和接受消息
                    c，删除邮箱
                创建新邮箱的进程默认为邮箱的拥有者。开始实，拥有者是唯一能通过该邮箱接受消息的进程，
                不过，系统调用，拥有权和接受权可能传递给其他进程。这会导致每个邮箱有多个接受者。

























