操作系统对于CPU活动的称呼：
    1，批处理系统执行作业
    2，分时系统使用用户程序或任务
    3，本书中经常使用作业与进程。

一，进程：
    进程不只是 程序代码，还包括 当前活动，进程堆栈段，数据段，还可能包括 堆。
        1，程序代码：称为代码段。
        2，当前活动，通过程序计数器的值和处理器寄存器的内容来表示。
        3，堆栈段：包括临时数据，如函数参数，返回地址，局部变量。
        4，数据段：全局变量。
        5，堆：进程运行期间动态运行的内存。

    程序本身不是进程：
        程序只是被动实体，如存储在磁盘上包含一系列指令的文件内容
        而进程是活动实体，有一个程序计数器用来表示下一个要执行的命令和相关资源集合。
        当一个可执行文件被装入内存时，一个程序才能成为进程。

二，进程状态：
    1，新的：进程正在被创建
    2，运行：指令正在被执行
    3，等待：进程等待某个时间的发生（如IO完成或收到信号）
    4，就绪：进程等待分配内存
    5，终止：进程完成执行

三，进程控制块（process control block ，PCB）：
    PCB包含了许多与一个特定进程相关的信息：
    1，进程状态：进程状态
    2，程序计数器：进程要执行的下个指令的地址
    3，CPU寄存器：计算机体系不同，寄存器的数量和类型不同。包括：累加器，索引寄存器，堆栈指针，通用寄存器和其他条件码信息寄存器。
    4，CPU调度信息：进程优先级，调度队列的指针和其他调度参数
    5，内存管理信息：根据操作系统所使用的内存系统，该信息包括基址，和界限寄存器的值，页表，或段表
    6，记账信息：该信息包括CPU时间，实际使用时间，时间界限，记账数据，作业或进程数量
    7，I/O状态信息：该信息包括分配给进程的I/O设备列表，打开的文件列表等
    PCB作为了这些信息的仓库。

四，进程调度：
    多道程序设计的目的是无论何时都有进程在运行，从而使CPU利用率达到最大化。
    分时系统的目的是在进程之间快速切换CPU以便用户在程序运行时能与其进行交互。
    进程调度：选择一个可用的进程（可能从多个可用进程集合中选择）到CPU上执行。

    1，调度队列：
        进程进入系统时，就加入到作业队列中，该队列中包括系统中的所有进程。
        驻留在内存中就绪的，等待运行的进程保存在就绪队列中。
        讨论进程调度的常用表示方法是队列图，有两种队列：就绪队列，一组设备队列。
        新进程开始处于就绪队列。它在就绪队列中等待直到被选中执行或被派遣。
        当进程分配到CPU并执行时，可能发生下面几种事件中的一种：
            a，进程可能发出一个I/O请求，并被放到I/O队列中。
            b，进程可能创建一个新的子进程，并等待其结束。
            c，进程可能由于中断而强制释放CPU，并被放回到就绪队列中。
        对于前两种情况，进程最终从等待状态切换到就绪态，并放回到就绪队列中。
        进程继续这一循环直到终止，到时它将从所有队列中删除，其PCB和资源将得以释放。

    2，调度程序：
        进程在 其生命周期中 会在 各种调度队列 之间迁移。
        为了调度，操作系统 必须按照 某种方式 从这些队列中 选择进程。
        进程选择 是由相对应的 调度程序 来执行。

      通过执行频率区分：
        长期调度程序 或 作业调度程序 从大容量存储设备（通常为磁盘）的 缓存池 中选择进程，并装入内存以准备执行。
        短期调度程序 或 CPU调度程序 从准备执行的进程中选择进程，并为之分配CPU。

        短期调度系统：
            短期调度程序需要频繁地为CPU选择新进程。由于执行之间的时间较短，短期调度程序必须要快。

        长期调度程序
            执行不频繁，在系统内新进程的创建之间可能有数分钟间隔。
            长期调度程序 控制 多道程序设计的程度----内存中的进程数量。
            如果 多道程序的程度 稳定 即指 创建进程 的平均速度 等于 进程离开系统 的平均速度。
            通常，绝大多数进程可以分为： I/O为主 或 CPU为主
            为了达到最好的性能，长期调度程序 应该选择一个合理的包含 I/O为主 和 CPU为主 的组合进程。
            有些系统，可能没有长期调度程序。例如 UNIX ，Windows等分时系统通常没有长期调度程序，
            只是简单地将所有新进程放在内存中以供短期调度程序使用。

        中期调度程序
            分时操作系统，引入了中期操作系统。
            核心思想：
                交换（swapping）：将进程中内存（或从 CPU竞争）中移出，从而降低 多道程序设计的程度。之后，进程能被重新调入内存，并从中断处继续执行。
                为了改善进程组合，或者因内存要求的改变引起了可用内存的过度使用而需要释放内存，就有必要使用交换。


    3，上下文切换：
        进程上下文用进程PCB表示，它包括 CPU寄存器的值，进程状态，和内存管理信息等。
            状态保存：保存CPU当前状态
            状态恢复：重新开始运行
        上下文切换：将 CPU切换到 另一个进程 需要保存 当前进程的状态 并 恢复另一个进程的状态。
        当发生上下文切换时，内核 会将 旧进程的状态 保存在其PCB中，然后装入 经调度要执行的并已保存的新进程的上下文。

五，进程操作
    1，进程创建
        大多数操作系统通过唯一的进程标识符来识别进程(process identifier, pid);
        通常，进程需要一定的资源（CPU时间，内存，文件，I/O设备）来完成其任务。
        在一个进程创建 子进程时，子进程 可能从 操作系统 那里直接获得资源，也可能只从其 父进程 那里获得资源。
        当进程创建新进程时，有两种执行可能：
            a，父进程与子进程并发执行。
            b，父进程等待，直到某个或全部子进程执行完。
        新进程的地址空间也有两种可能：
            a，子进程是父进程的复制品（具有与父进程相同的程序和数据）。
            b，子进程装入另一个新程序。

        在UNIX下，每个进程都用唯一的整数形式的进程标识符。
            通过fork()系统调用，可创建新进程。
            新进程通过复制原来进程的地址空间而成。两个进程都继续执行位于系统调用fork()之后的指令。
            但是，对于子进程，系统调用fork()的返回值为0，，对于父进程，系统调用fork()返回子进程的pid。

            通常，在系统调用fork()后，一个进程会使用，系统调用exec()，以用新程序来取代进程的内存空间。
            系统调用exec()将二进制文件装入内存，并开始执行。
            父进程能创建更多的子进程，或者如果子进程在运行时没什么可做，那么它采用系统调用wait()把自己移出就绪队列类等待子进程的终止。




















