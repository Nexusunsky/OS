##客户机-服务器系统通信
    可进行客户机-服务器系统通信方法的技术：
        1，共享内存，
        2，消息传递，
        3，Socket，
        4，远程过程调用(RPC)，
        5，Java的远程方法调用(RMI)

Socket:

远程过程调用：
    RPC设计成抽象过程调用，用于通过网络连接系统。
    类似于IPC机制，并且通常建立在这种系统之上。
    因为在所处理的环境中，进程在不同系统上执行，所以必须提供基于消息的通信方案来提供远程服务。
    而与IPC不同的是，用于RPC交换的信息是有很好的结构，而不在仅仅是数据包。
    每个消息传递给位于远程系统上监听端口号的RPC服务器，每个都含有执行函数的名称和传递给函数的参数。
    而函数根据请求执行，任何结果通过另一个消息送回给请求者。

    端口只是一个数字，并包含在消息包的开始处。
    虽然一个系统通常只有一个网络地址，但是它在这一地址内有许多端口号以区分所支持的多种网络服务。
    如果一个远程进程需要服务，那么它就向适当端口发送消息。

    RPC语义：
        允许客户机调用位于远程主机上的过程，就如同调用本地过程一样。
        通过在客户端提供存根(stub)，RPC隐藏了允许通信发送的必要细节。
        通常，对于每个独立的远程过程都有个 存根。
            当客户机调用远程过程时，RPC系统调用合适的 存根，并传递远程过程参数。
            该存根位于 服务器的 端口，并编组(marshal)参数----参数编组涉及将参数打包成可通过网络传输的形式。
            接着存根 使用 消息传递 向服务器 发送一个消息。服务器 的一个 类似存根 接收到这一消息，并调用 服务器上的 过程。
            有必要时，返回值可通过同样技术返回给客户机。

    注意事项：
        1，处理 客户机 和 服务器 系统的 数据表示的差别。
        考虑 一个 32位整数的表示。
            有的系统使用高内存地址以存储 高字节（称为大尾端，big-endian）
            其他系统使用高内存地址以存储 低字节（称为小尾端，little-endian）
        处理这类问题许多RPC系统都定义了 数据的机器无关表示，一种这样的表示称为 外部数据表示（XDR）
        客户机端：参数编组 涉及将机器有关数据 在被发送到服务器之前 编组成XDR。
        服务器端，XDR数据重新转换成服务器所用的机器有关表示。

        2，另一个重要的事项是，调用的语义。
            虽然本地过程调用只有在极端情况下才可能失败，但是由于普通网络错误，RPC可能会失败或重复多次执行。
            处理方案是让操作系统确保一个消息 刚好执行一次，而不是 最多执行一次。

        最多一次：通过为每个消息附加时间戳的方法实现。
        刚好一次：客户机必须周期性重发每个RPC调用，直到它接收到对该调用的ACK。

        3，服务器与客户机的通信问题。
            对于标准过程调用，在连接，装入或执行时会出现一点形式的绑定，从而使过程名称被过程的内存地址所代替。
            RPC方案要求有一个类似于客户机和服务器端口的绑定，由于客户机和服务器之间没有共享内存，需要特定方案来实现。
                a，绑定信息以固定端口地址形式预先固定。编译时，RPC调用一个相应的固定端口，一旦程序编译后，服务器不能改变请求服务的端口号。
                b，绑定通过 集合点机制 动态地进行，通常操作系统在一个 固定RPC端口 上提供 集合点服务程序（matchmaker）。客户机发送一个包括 RPC名称 的消息给 集合点服务程序，
                以请求它所需要执行的 RPC端口地址。该端口号返回，RPC调用可发送到这一端口号直到 进程终止（或服务器失败），这种方式需要 初试请求的额外开销，但是比第一种方案灵活。



远程方法调用：
    远程方法调用（remote method invocation ,RMI）类似于RPC的Java特性。

    RMI 和 RPC 区别：
    1，RPC支持子程序编程，即只能调用远程的子程序或函数；而RMI是基于对象的，它支持远程调用远程对象的方法。
    2，在RPC中，远程过程的参数是普通数据结构，而RMI可以将对象作为参数传递给远程方法。
    RMI通过允许java程序调用远程对象的方法，使得用户能够开发分布在网络上的Java应用程序。

    RMI原理：
        采用存根(stub)和骨干(skeleton)实现远程对象。
        1，存根为远程对象的 代理，驻留在 客户机。当 客户机 调用 远程方法时，远程对象的存根 被调用。
        2，这种 客户端存根 负责创建一个 包，它具有 服务器上要调用 方法的名称 和用于该 方法的编排参数。
        3，存根 将该包发送给 服务器，远程对象的骨干 会接收它。骨干负责 创建 重新编排参数 并调用 服务器上所要执行的真正的方法。
        4，骨干 接着 编排返回值（或异常），然后打包，并将包返回给 客户机，存根重新 编排返回值，并传递给 客户机。


    RMI参数传递行为的规则：
        1，编排参数 是本地（非远程）对象，那么通过称为 对象串行化技术 来复制传递。
           不过，如果参数也是 远程对象，那么可以通过 引用传递。

        2，如果 本地对象 需要作为参数 传递给 远程对象，那么就必须实现Serializable接口。
           允许将串行化对象状态写入字节流。











