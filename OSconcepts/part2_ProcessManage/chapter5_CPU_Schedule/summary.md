# CPU 调度
    1，前言：
        a，CPU调度是多道程序操作系统的基础，通过在进程之间切换CPU，操作系统可以提高计算机的吞吐量。
        b，内核级的线程是被操作系统调度而不是进程。
        c，线程调度或进程调度常常被交替使用。

    2，基本概念：
        多道程序的目标是在 任何时候 都有某些 进程在运行，以使 CPU使用率最大化，
        多个进程可同时处于内存中，当一个进程必须等待时，操作系统会从该进程拿走CPU的使用权，而将CPU交给其他进程。
        CPU调度是操作系统的基本功能，几乎所有的资源在使用前都要调度。

    3，CPU-I/O 区间周期
        进程执行由 CPU执行 和 I/O等待 周期组成，进程在这 两个状态（CPU区间，I/O区间） 之间切换。
        I/O约束进程 通常具有很多 短CPU区间。
        CPU约束进程 可能 有少量的 长CPU区间。

    4，CPU调度程序
        每当CPU空闲时，操作系统 就必须从 就绪队列中 选择 一个 进程 来执行。
        a，而 选择 的工作使用 短期调度程序 或 CPU调度程序 执行。
        b，就绪队列 可以是 FIFO 队列，优先队列，树或简单的无序链表。队列中的纪录通常为进程控制块（PCB）。

    5，抢占调度
    CPU调度发生的四种环境：
        a，当一个进程从 运行状态 切换到 等待状态
        b，当一个进程从 运行状态 切换到 就绪状态
        c，当一个进程从 等待状态 切换到 就绪状态
        d，当一个进程终止时。

    对于a，d两种情况必须调度，一个 新进程 必须被选择执行，此时的调度方案是 非抢占的 或 协作的。
    对于b，c两种情况，可以进行选择，此时的调度方案是 抢占的

    对于非抢占调度，，一旦CPU非配给一个线程，那么该进程会一直使用CPU直到 进程终止 或 切换到等待状态。
    在有些操作系统上，非抢占调度是硬件平台的唯一方法，因为它不要求抢占调度所需要的特别的硬件的支持。

    对于抢占调度：
        a，抢占调度对访问共享数据有代价，可能参数数据不一致的情形，需要使用新的机制来协调对共享数据的访问。
        b，对于操作系统内核的设计也有影响。
        c，中断是能随时发生，而且不能总是被内核所忽略。所有受中断影响的代码段必须加以保护以避免同时访问。

    6，分派程序
        分派程序 是一个另一个和 CPU调度有关 的模块，用来将 CPU的控制 交给由 短期调度程序 选择的进程。其功能包括：
            a，切换上下文
            b，切换到用户模式
            c，跳转到用户程序的合适位置，以重新启动程序

    7，调度准则：
       最佳 CPU调度算法 特征 进行比较

        a，CPU使用率：真实系统中，CPU的使用率为 40%（轻负荷） ~ 90%（重负荷）
        b，吞吐量：测量工作量的方法，指一个 时间单元内 所 完成 进程的数量。
        c，周转时间：运行该进程需要多长时间，从进程提交到进程完成的时间，
           为所有时间段之和，包括 A，等待进入内存，在 B，就绪等待队列中等待，在 C，CPU上执行，和 D，I/O执行
        d，等待时间：CPU调度算法并不影响进程运行和执行IO的时间，只影响进程在队列中等待的时间，只在就绪队列中等待的时间。
        e，响应时间：从提交请求到产生第一响应的时间。

        总结：需要是 CPU使用率 和 吞吐量 最大化，等待时间 和 响应时间 最小化。
            a，保证用户得到好的服务，可能需要使最大响应时间最小。
            b，对于交互系统（如分时系统）最小化响应时间的方差要比最小化平均时间更为重要


    8，调度算法
        CPU调度处理是从就绪队列中选择进程并为之分配CPU的问题

    a，先到现服务调度（first come first served FCFS）
        可以使用FIFO队列轻松实现。
        当一个进程进入到就绪队列，其PCB连链接到队列的尾部。
        当CPU空闲时，CPU非配给位于队列头的进程，接着该运行进程从队列中删除。

        1，FCFS 策略的 平均等待 时间通常较长。
        2，考虑 FCFS 调度 在动态 情况下的性能，容易产生，CPU空闲 和 IO设备空闲 的情况。
        3，FCFS 调度算法是非抢占的，一旦CPU被分配给一个进程，该进程就会保持CPU直到释放CPU为止。
           FCFS算法对于分时系统（每个用户需要定时的得到一定的CPU时间）特别麻烦，允许一个进程保持CPU时间过长将是严重的错误。


    b，最短作业优先调度（shortest-job-first SJF）
        将每个进程和其下一个CPU时间段相关联。
        CPU空闲时，它将会被分派给具有 最短CPU时间 的进程。而同等长度的 两个进程 使用 FCFS调度。
        注意：一个更为合适的表示是，最短 下一个 CPU时间 的算法，这是因为调度检查进程的 下一个 CPU区间 的长度，而不是其 总长度。

        1，SJF算法可证明是最佳的，对于给定的一组进程，SJF算法的平均等待时间最小。将短进程等待时间提前到长进程等待时间之前，降低了整体等待时间。
        2，SJF算法困难是如何直到下一个CPU区间的长度，对于批处理系统的长期调度，可以将提交作业时所指定的进程时间极限作为长度。SJF经常用于长期调度。
        3，虽然SJF最佳，但是不能在短期CPU调度层次上加以实现，因为没有办法知道下一个CPU区间的长度，
           一种方法是 近视SJF调度：通过计算下一个 CPU区间长度 的近似值，能选择具有 最短预测CPU区间 的进程来运行。
           下一个CPU区间通常可以预测为以前CPU区间的测量长度的指数平均。
        4，SJF算法可能是抢占的或非抢占的：
            SJF抢占算法（shortest-remaining-time-first ）比较 新进程 和 就绪队列中以前进程 比较下一个CPU区间 ，执行更小的进程。
            而非抢占SJF则无论哪个更小，会允许当前允许的进程优先完成其CPU区间。


    c，优先级调度
        1，每个进程都有一个 优先级 与其关联，具有 最高优先级 的进程会 分配到CPU，相同 优先级的进程 按 FCFS 顺序调度。
            例子：
                SJF算法 可作为通用 优先级调度算法 的一个特例。
                属于 简单优先级算法，其 优先级(p)为下一个 CPU区间的倒数。CPU区间 越大，则优先级 越小，反之亦然。


        2，优先级可以通过
            内部方式：
                优先级使用一些 测量数据 以计算进程优先级。例如，时间极限，内存要求，打开文件的数量，平均CPU区间和平均IO区间之比。

            外部方式：
                通过操作系统之外的准则定义，如进程重要性，用于费用，其它政治原因。

        3，优先级调度 可以是 抢占式 的也可以是 非抢占式的，
            当一个进程到达 就绪队列 时，其 优先级 与 当前运行进程 相比较，
            抢占式：
                如果 新的到达进程 的 优先级 高于 当前运行进程的优先级，那么 抢占优先级调度算法会抢占CPU。
            非抢占式：
                非抢占优先级算法只是将新进程加到就绪队列的头部。


        4，优先级调度算法的一个主要问题是 无穷阻塞（indefinite blocking） 或 饥饿（starvation）
            对于 可以运行 但是 缺乏CPU 的进程可以认为是 阻塞的，它在等待CPU。因此 优先级调度算法 会使某个 低优先级进程 陷入 无穷等待CPU的状态。
            而解决该现象的一种 技术称为 老化（aging）：以 逐渐增加 系统中 等待很长时间进程 的优先级。



    d，轮转法（round-robin）调度
        1，轮转法是专门为 分时系统所设计，类似与FCFS调度。但是增加了抢占以切换进程。
           定义 一个较小时间单元，称为时间片（time quantum，or time slice）时间片通常 为 10～100ms。
           将 就绪队列 作为循环队列，CPU 调度程序虚幻就绪队列，为每一个进程分配不超过一个时间片的CPU。

        2，实现：
           将 就绪队列 保存为 进程的 FIFO队列。新进程 增加到 就绪队列的尾部。
           CPU 调度 程序 从 就绪队列 中选择一个进程，设置 定时器 在一个 时间片 之后中断，在分配该进程。
           当分配 进程 给CPU时，
                如果，进程只需要小于 时间片 的CPU区间，那么进程本身会自动释放CPU，调度程序接着处理就绪队列中的下一个进程。
                如果，进程需要的 CPU区间 长于 的时间片，那么定时器 会到时触发 操作系统中断，然后进行上下文切换。将进程加入到 就绪队列的尾部，接着CPU调度程序会选择就绪队列中的下一个进程。

        3，性能：
            RR策略的平均等待时间通常较长。对于RR调度算法，队列中没有 进程 被分配 超过 一个时间片 的CPU时间，
            如果进程的CPU时间超过了一个时间片，那么该进程会被抢占，而被放回到就绪队列。
            RR算法的性能很大程度上依赖于时间片的大小。
                极端情况：
                如果时间片非常大，那么RR算法和FCFS算法一样，那么RR算法称为处理器共享。
                    硬件：
                        那么n个进程对于用户都有它自己的处理器，速度为真正处理器速度的1/n。
                        这种方法用在Control Data Corporation（CDC）的硬件上。实现使用一组硬件和10组寄存器实现10个外设处理器。
                        硬件为 一组寄存器 执行一个指令。然后为下一组执行。形成了10个慢处理器而不是快处理器。
                    软件：
                        必须考虑上下文切换对RR调度的影响
                事实上，绝大多数操作系统的时间分配为10～100ms，上下文切换的时间一般小于10us，因此上下文切换的时间仅为时间的一部分。
                尽管时间片应该要比上下文切换时间长，但也不能太大，那么RR调度算法就演变成了FCFS算法，经验值，80%的CPU区间应该小于时间片。

    e，多级队列调度
        在进程可以容易地分成不同组的情况下，可以建立另一类调度算法。
        多级队列调度算法（multilevel queue scheduling algorithm）将 就绪队列分 成 多个队列，每个队列 有自己的 调度算法。
        而队列之间也必须要有调度，通常采用 固定优先级 抢占调度。


        例如，
             a，一个常用的划分方法是前台（交互）进程和后台（批处理）进程。
             这两种不同类型的进程具有不同响应时间要求，也有不同调度需要，另外，前台进程要有更高的优先级。
             那么前台进程和后台进程可处于不同的队列中，前台进程 可能采用RR算法调度，后台队列采用FCFS算法调度。
             前台队列 可以比 后台队列 具有 绝对的优先级。

             b，具有5个队列的多级队列调度算法的例子，按优先级排列。
                系统进程
                交互进程
                交互编辑进程
                批处理进程
                学生进程
        1，每个队列与 更低层次队列 相比有 绝对的优先级，只有系统进程，交互进程和交互编辑进程都为空时，批处理队列中的进程才能运行。
           而当在批处理进程运行时有一个交互进程进入就绪队列，那么该批处理进程就会被抢占。
        2，另一种方式是在 队列之间划分 时间片，每个队列之间都有一定的CPU时间，可用于调度队列内的进程。

    f，多级反馈队列调度
       多级队列调度 不允许 进程在队列之间迁移，当进程进入系统时被永久地分配到一个队列。

       多级反馈队列调度运行进程 允许 进程在队列 之间 移动，主要思想是 根据不同 CPU区间 的特点区分进程。
       如果进程使用过多CPU时间，那么它会被转移到更低优先级队列，这种方案将IO约束进程和交互进程留在更高优先级队列。
       同时，在较低优先级队列中等待时间过长的进程会被 转移 到更高优先级队列，这种形式的 老化 阻止 饥饿 发生。

       多级反馈队列调度程序可由下列参数来定义：
           a，队列数量
           b，每个 队列的 调度算法
           c，用以确定 何时升级 到 更高优先级队列的方法
           d，用以确定 何时降低 到 更低优先级队列的方法
           e，用以确定 进程 在需要CPU调度时时应进入哪个队列的方法

    总结：多级反馈队列调度 是 最通用的 CPU调度算法，可配置以适应特定系统设计，
          但是由于需要一些方法来选择参数定义最佳调度程序，它也是复杂的算法。
































