# CPU 调度
    1，前言：
        a，CPU调度是多道程序操作系统的基础，通过在进程之间切换CPU，操作系统可以提高计算机的吞吐量。
        b，内核级的线程是被操作系统调度而不是进程。
        c，线程调度或进程调度常常被交替使用。

    2，基本概念：
        多道程序的目标是在 任何时候 都有某些 进程在运行，以使 CPU使用率最大化，
        多个进程可同时处于内存中，当一个进程必须等待时，操作系统会从该进程拿走CPU的使用权，而将CPU交给其他进程。
        CPU调度是操作系统的基本功能，几乎所有的资源在使用前都要调度。

    3，CPU-I/O 区间周期
        进程执行由 CPU执行 和 I/O等待 周期组成，进程在这 两个状态（CPU区间，I/O区间） 之间切换。
        I/O约束进程 通常具有很多 短CPU区间。
        CPU约束进程 可能 有少量的 长CPU区间。

    4，CPU调度程序
        每当CPU空闲时，操作系统 就必须从 就绪队列中 选择 一个 进程 来执行。
        a，而 选择 的工作使用 短期调度程序 或 CPU调度程序 执行。
        b，就绪队列 可以是 FIFO 队列，优先队列，树或简单的无序链表。队列中的纪录通常为进程控制块（PCB）。

    5，抢占调度
    CPU调度发生的四种环境：
        a，当一个进程从 运行状态 切换到 等待状态
        b，当一个进程从 运行状态 切换到 就绪状态
        c，当一个进程从 等待状态 切换到 就绪状态
        d，当一个进程终止时。

    对于a，d两种情况必须调度，一个 新进程 必须被选择执行，此时的调度方案是 非抢占的 或 协作的。
    对于b，c两种情况，可以进行选择，此时的调度方案是 抢占的

    对于非抢占调度，，一旦CPU非配给一个线程，那么该进程会一直使用CPU直到 进程终止 或 切换到等待状态。
    在有些操作系统上，非抢占调度是硬件平台的唯一方法，因为它不要求抢占调度所需要的特别的硬件的支持。

    对于抢占调度：
        a，抢占调度对访问共享数据有代价，可能参数数据不一致的情形，需要使用新的机制来协调对共享数据的访问。
        b，对于操作系统内核的设计也有影响。
        c，中断是能随时发生，而且不能总是被内核所忽略。所有受中断影响的代码段必须加以保护以避免同时访问。

    6，分派程序
        分派程序 是一个另一个和 CPU调度有关 的模块，用来将 CPU的控制 交给由 短期调度程序 选择的进程。其功能包括：
            a，切换上下文
            b，切换到用户模式
            c，跳转到用户程序的合适位置，以重新启动程序

    7，调度准则：
       最佳 CPU调度算法 特征 进行比较

        a，CPU使用率：真实系统中，CPU的使用率为 40%（轻负荷） ~ 90%（重负荷）
        b，吞吐量：测量工作量的方法，指一个 时间单元内 所 完成 进程的数量。
        c，周转时间：运行该进程需要多长时间，从进程提交到进程完成的时间，
           为所有时间段之和，包括 A，等待进入内存，在 B，就绪等待队列中等待，在 C，CPU上执行，和 D，I/O执行
        d，等待时间：CPU调度算法并不影响进程运行和执行IO的时间，只影响进程在队列中等待的时间，只在就绪队列中等待的时间。
        e，响应时间：从提交请求到产生第一响应的时间。

        总结：需要是 CPU使用率 和 吞吐量 最大化，等待时间 和 响应时间 最小化。
            a，保证用户得到好的服务，可能需要使最大响应时间最小。
            b，对于交互系统（如分时系统）最小化响应时间的方差要比最小化平均时间更为重要


    8，调度算法
        CPU调度处理是从就绪队列中选择进程并为之分配CPU的问题

    a，先到现服务调度（first come first served FCFS）
        可以使用FIFO队列轻松实现。
        当一个进程进入到就绪队列，其PCB连链接到队列的尾部。
        当CPU空闲时，CPU非配给位于队列头的进程，接着该运行进程从队列中删除。

        1，FCFS 策略的 平均等待 时间通常较长。
        2，考虑 FCFS 调度 在动态 情况下的性能，容易产生，CPU空闲 和 IO设备空闲 的情况。
        3，FCFS 调度算法是非抢占的，一旦CPU被分配给一个进程，该进程就会保持CPU直到释放CPU为止。
           FCFS算法对于分时系统（每个用户需要定时的得到一定的CPU时间）特别麻烦，允许一个进程保持CPU时间过长将是严重的错误。


    b，最短作业优先掉地（shortest-job-first SJF）
        将每个进程和其下一个CPU时间段相关联。
        CPU空闲时，它将会被分派给具有 最短CPU时间 的进程。而同等长度的 两个进程 使用 FCFS调度。
        注意：一个更为合适的表示是，最短 下一个 CPU时间 的算法，这是因为调度检查进程的 下一个 CPU区间 的长度，而不是其 总长度。

        1，SJF算法可证明是最佳的，对于给定的一组进程，SJF算法的平均等待时间最小。将短进程等待时间提前到长进程等待时间之前，降低了整体等待时间。
        2，SJF算法困难是如何直到下一个CPU区间的长度，对于批处理系统的长期调度，可以将提交作业时所指定的进程时间极限作为长度。SJF经常用于长期调度。
        3，虽然SJF最佳，但是不能在短期CPU调度层次上加以实现，因为没有办法知道下一个CPU区间的长度，
           一种方法是 近视SJF调度：通过计算下一个 CPU区间长度 的近似值，能选择具有 最短预测CPU区间 的进程来运行。
           下一个CPU区间通常可以预测为以前CPU区间的测量长度的指数平均。
        4，SJF算法可能是抢占的或非抢占的：
            SJF抢占算法（shortest-remaining-time-first ）比较 新进程 和 就绪队列中以前进程 比较下一个CPU区间 ，执行更小的进程。
            而非抢占SJF则无论哪个更小，会允许当前允许的进程优先完成其CPU区间。

































