# 进程同步

    1，背景：
        协作进程：系统内执行的 其他进程 相互影响 的进程，
        互相协作的进程
            可以
                直接共享 逻辑地址空间（代码和数据），通过 轻量级进程或线程 实现
            或者
                只通过 文件或消息 来共享数据。
        共享数据的 并发访问 后产生数据的 不一致。
        本章将讨论 各种机制，确保 共享 同一逻辑地址空间的协作进程 可 有序地执行。

        竞争条件：多个进程 并发 访问和操作 同一数据 且执行结果与 访问发生的特定顺序有关。
        避免 竞争条件 就需要 一端时间内 只有一个进程 能操作变量。

    2，临界区问题：
        每个进程有个代码段：临界区，在该区中 进程可能改变 共同变量（表，文件等）
        特征当一个进程进入临界区时，没有其他进程可被允许在 临界区执行

        设计一个 以便 进程协作的协议：
            每个进程必须请求进入其 临界区。实现这一请求的代码段称为 进入区（entry section）
            临界区（critical section）之后 可有退出区（exit section），其他代码为剩余区（remainder section）

        必须满足三项要求：
            a，互斥（mutual exclusion）：
                如果进程Pi在临界区执行，那么 其他进程 都不能在其 临界区执行。
            b，前进（progress）:
                如果没有进程在临界区内执行，且有进程需要进入临界区，那么只有那些不在剩余区内执行的进程可参加选择已确定能够下一个进入临界区，而且这种选择不可被无限推迟。
            c，有限等待（bounded waiting）：
                从一个进程 做出进入临界区的请求，直到该请求允许为止，其他进程 允许进入其 临界区的次数 有上限。


        问题：
            操作系统中，存在有产生竞争条件的情况：
                某个时刻，可同时存有多个处于内核模式的活动进程，实现操作系统的代码会出现竞争条件，
                有两种方法用于处理操作系统内的临界区问题：
                    抢占内核（preemptive）:
                        允许处于内核模式的进程被抢占，抢占内核需要认真设计确保数据结构不会导致竞争条件，SMP体系结构，抢占内核更难设计，
                        因为处于两个内核模式的进程同时运行在不同的处理器上。
                    非抢占内核(nonpreemptive kernel) :
                        不允许处于内核模式的进程被抢占，而非抢占内核模式的数据结构，从根本上而言，不会导致竞争条件。
                        处于内核模式运行的 进程会一直运行，直到它退出内核模式，阻塞或自动退出CPU的控制。


    3，Peterson算法：
        适用：
            两个进程在 临界区 和 剩余区 交替执行。
        共享：
            Peterson需要在 两个进程之间 共享两个数据项，
                int turn;
                    表示哪个进程 可以 进入其临界区。

                boolean flag[2];
                    表示哪个进程 想要 进入其临界区。
```
        //进程 Pi
        do {
            flag[i] = TRUE;
            turn = j;
            while (flag[j] && turn == j)
                ;

            // 临界区

            flag[i] = FALSE

            //剩余区
        } while(TRUE);

        //进程 Pj
        do {
            flag[j] = TRUE;
            turn = i;
            while (flag[i] && turn == i)
                ;

            // 临界区

            flag[j] = FALSE

            //剩余区
        } while(TRUE);
```
        为了进入临界区，进程Pi 首先设置flag[i] = true ，且turn=j
            表示：表示Pi想要进入临界区，Pj进程 可以 进入临界区，

        现在需要 算法 能解决 临界区问题：
            1，互斥：
                当flag[i] = flag[j] = TRUE
                turn只能在同一时刻 i, j之间的某一个值。
                并且当 turn的 值 确定时，只能有一个进程 进入其临界区。另一个会 在while中等待。

            2，前进：
                假设：flag[j]==true 和 turn==j 成立。然后Pi陷入while，那么将不能进入临界区。
                Pj处于剩余区 不准备进入临界区，则 flag[j] == false ，Pi进入从while 中出来进入临界区。
                如果Pj设置了flag[j] = true，且进入了 while中。
                此时 turn == i 或 turn == j，一个在临界区，一个在while中
                    当turn == i时 则 Pi进入临界区，
                    当turn == j时 则 Pj进入临界区
                当其中之一退出时，假设为Pj退出临界区，此时，flag[j] = false，那么进入了while的进程Pi将 进入到临界期。
                而 Pj 便在 剩余区中，
                
            3，有限等待：
                由上述的 Pi和Pj进程 的所执行的 代码区段 的交替，那么当 其中之一进程 跨越临界区一次 之后就能进入自己的临界区。
        
        
    4，硬件同步
        一般而言，任何临界区都需要 一个简单的工具 ---- 锁。
        原理：通过要求临界区 用锁 来保护，就可以避免 竞争条件，即 一个进程在进入 临界区之前必须得到锁，而在退出临界区时 释放锁。
        
        单处理器环境：
            非抢占内核使用：修改共享变量时，禁止中断出现，确保当前指令序列的执行不会被中断，确保共享变量不会被意外修改。
        
        多处理器环境：
            许多现代计算机系统提供了 特殊硬件指令 以允许 原子地 检查和修改字的内容或交换两个字的内容。    

'''
    do{
        waiting[i] = TRUE;
        key = TRUE;
        while (waiting[i] && key)
            key = TestAndSet(&lock);
        waiting[i] = FALSE;
        
        // critical section
        
        //循环扫描 waiting[i] (i+1, i+2, i+3....,n-1,0,....,i-1) 
        //根据 这一顺序而指派第一个等待进程 作为下一个进入临界区的进程。
        j = (i + 1) % n;
        while((j!=i) && !waiting[j])
            j = ( j + 1 ) % n;
        
        if(j == i)
            lock = FALSE;
        else 
            waiting[j] = FALSE
        
        //reminder section            
    } while(TRUE);
'''       
         使用指令 TestAndSet算法，公用数据结构如下：
                 boolean waiting[n];
                 boolean lock;    
         只有当waiting[i] == false 或 key == false时，进程Pi才进入临界区。    
         只有当TestAndSet执行时，key的值才能变成false 所有其他进程必须等待。
         只有其他进程离开临界区时，变量waiting[i]的值才能变成false，每次只有一个waiting[i]被设置为false。以满足互斥。   
         由于进程在退出临界区时 或将 lock 设为false 或将 waiting[j]设为false。这两种情况 都允许 等待进程 进入 临界区以执行。
         任何等待进入临界区的进程只需要等待 n-1 次。   

    5，信号量：
        基于硬件的临界问题解决方案（采用TestAndSet() 与 Swap()指令）但是对于 应用程序而言，使用比较复杂，
        为了 解决这个困难，可以使用 信号量（semaphore）的同步工具。
        信号量S 是个整数变量，除了初始化之外，
            它只能通过两个标准原子操作：
                wait()
                signal()

```
    wait(S) {
        while(S<=0)
            ;// no-op
        S--;
    }
    
    signal(S) {
        S++;
    }
```            
    在 wait() 和 signal() 操作中，对 信号量整形值 的修改必须 不可分地执行，
    即当一个进程 修改信号量值时，不能有 其他进程 同时 修改同一信号量的值。
    另外，对于wait(S) 对 S的整形值 的测试(S<=0) 和对其可能修改（S--）也必须不被中断执行

        a，用法：
            





