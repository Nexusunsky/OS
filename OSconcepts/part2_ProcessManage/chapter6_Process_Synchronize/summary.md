# 进程同步

    1，背景：
        协作进程：系统内执行的 其他进程 相互影响 的进程，
        互相协作的进程
            可以
                直接共享 逻辑地址空间（代码和数据），通过 轻量级进程或线程 实现
            或者
                只通过 文件或消息 来共享数据。
        共享数据的 并发访问 后产生数据的 不一致。
        本章将讨论 各种机制，确保 共享 同一逻辑地址空间的协作进程 可 有序地执行。

        竞争条件：多个进程 并发 访问和操作 同一数据 且执行结果与 访问发生的特定顺序有关。
        避免 竞争条件 就需要 一端时间内 只有一个进程 能操作变量。

    2，临界区问题：
        每个进程有个代码段：临界区，在该区中 进程可能改变 共同变量（表，文件等）
        特征当一个进程进入临界区时，没有其他进程可被允许在 临界区执行

        设计一个 以便 进程协作的协议：
            每个进程必须请求进入其 临界区。实现这一请求的代码段称为 进入区（entry section）
            临界区（critical section）之后 可有退出区（exit section），其他代码为剩余区（remainder section）

        必须满足三项要求：
            a，互斥（mutual exclusion）：
                如果进程Pi在临界区执行，那么 其他进程 都不能在其 临界区执行。
            b，前进（progress）:
                如果没有进程在临界区内执行，且有进程需要进入临界区，那么只有那些不在剩余区内执行的进程可参加选择已确定能够下一个进入临界区，而且这种选择不可被无限推迟。
            c，有限等待（bounded waiting）：
                从一个进程 做出进入临界区的请求，直到该请求允许为止，其他进程 允许进入其 临界区的次数 有上限。


        问题：
            操作系统中，存在有产生竞争条件的情况：
                某个时刻，可同时存有多个处于内核模式的活动进程，实现操作系统的代码会出现竞争条件，
                有两种方法用于处理操作系统内的临界区问题：
                    抢占内核（preemptive）:
                        允许处于内核模式的进程被抢占，抢占内核需要认真设计确保数据结构不会导致竞争条件，SMP体系结构，抢占内核更难设计，
                        因为处于两个内核模式的进程同时运行在不同的处理器上。
                    非抢占内核(nonpreemptive kernel) :
                        不允许处于内核模式的进程被抢占，而非抢占内核模式的数据结构，从根本上而言，不会导致竞争条件。
                        处于内核模式运行的 进程会一直运行，直到它退出内核模式，阻塞或自动退出CPU的控制。


    3，Peterson算法：
        适用：
            两个进程在 临界区 和 剩余区 交替执行。
        共享：
            Peterson需要在 两个进程之间 共享两个数据项，
                int turn;
                    表示哪个进程 可以 进入其临界区。

                boolean flag[2];
                    表示哪个进程 想要 进入其临界区。
'''
        //进程 Pi
        do {
            flag[i] = TRUE;
            turn = j;
            while (flag[j] && turn == j)
                ;

            // 临界区

            flag[i] = FALSE

            //剩余区
        } while(TRUE);

        //进程 Pj
        do {
            flag[j] = TRUE;
            turn = i;
            while (flag[i] && turn == i)
                ;

            // 临界区

            flag[j] = FALSE

            //剩余区
        } while(TRUE);
'''
        为了进入临界区，进程Pi 首先设置flag[i] = true ，且turn=j
            表示：表示Pi想要进入临界区，Pj进程 可以 进入临界区，

        现在需要 算法 能解决 临界区问题：
            1，互斥：
                当flag[i] = flag[j] = TRUE
                turn只能在同一时刻 i, j之间的某一个值。
                并且当 turn的 值 确定时，只能有一个进程 进入其临界区。另一个会 在while中等待。

            2，前进：
                假设：flag[j]==true 和 turn==j 成立。然后Pi陷入while，那么将不能进入临界区。
                Pj处于剩余区 不准备进入临界区，则 flag[j] == false ，Pi进入从while 中出来进入临界区。
                如果Pj设置了flag[j] = true，且进入了 while中。
                此时 turn == i 或 turn == j，一个在临界区，一个在while中
                    当turn == i时 则 Pi进入临界区，
                    当turn == j时 则 Pj进入临界区
                当其中之一退出时，假设为Pj退出临机区，此时，flag[j] = false，然后只有从剩余区出来
                是的flag[j] = true ，turn = i，那么在Pi执行 while 时，并不能 turn 等值，但是
                Pi却由于Pj的在代码区段的变化 进入 临界区，发生 前进。

            3，有限等待：
                由于 Pi 和 Pj 之间 在进出 代码区段时，最多仅在另一个 进程进入临界区一次后 便能 进入临界区。



















